fun! LoadFiles(files)
    for file in a:files
        if filereadable(expand(file))
            execute "source " . file
        endif
    endfor
endfun

fun! SetupVimPlug()
    " Define our install dir and add it to our runtime path
    let plugin_root_dir = expand('$HOME', 1) . '/.config/nvim/plugins'
    let &rtp .= (empty(&rtp) ? '' : ',') . plugin_root_dir.'/vim-plug'

    " Clone vim-plug if we don't have it yet
    if !isdirectory(plugin_root_dir . '/vim-plug')
        echo "***********************************"
        echo "*   First time using this init.vim   *"
        echo "* Installing vim-plug and plugins *"
        echo "***********************************"
        silent execute '!git clone --depth=1 https://github.com/junegunn/vim-plug ' shellescape(plugin_root_dir . '/vim-plug', 1)
        let g:first_run = 1
    endif

    call LoadFiles([plugin_root_dir . '/vim-plug/plug.vim'])

    call plug#begin(plugin_root_dir)
    call LoadFiles(["~/.config/nvim/bundles"])
    call plug#end()

    if exists('g:first_run')
        PlugInstall

        # Install typescript and rust language servers
        CocInstall coc-tsserver
        CocInstall coc-rls
    endif
endfun

" StripTrailingWhitespace {{{
function! StripTrailingWhitespace()
  if exists('b:noStripWhitespace')
    return
  endif

  " Preparation: save last search, and cursor position.
  let _s=@/
  let l = line(".")
  let c = col(".")
  " do the business:
  %s/\s\+$//e
  " clean up: restore previous search history, and cursor position
  let @/=_s
  call cursor(l, c)
endfunction
" }}}

"FZF open
function! s:get_git_root()
    if exists('*fugitive#repo')
        try
            return fugitive#repo().tree()
        catch
        endtry
    endif
    let root = split(system('git rev-parse --show-toplevel'), '\n')[0]
    return v:shell_error ? '' : root
endfunction

"If in a git repository then only search the files checked into git.
function! SmartFzfSearching()
    let root = s:get_git_root()
    if empty(root)
        Files
    else
        GFiles
    endif
endfunction
